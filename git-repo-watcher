#!/bin/bash

# -------------------------------------------------------------------- #
# CONFIGURATION
# -------------------------------------------------------------------- #

DIR_TO_SYNC_IN="test/example-repository"
LOOP_INTERVAL_IN_SECONDS=10
CREDENTIAL_HELPER_CACHE_IN_SECONDS=$(($LOOP_INTERVAL_IN_SECONDS+600))

# -------------------------------------------------------------------- #
# CUSTOM HANDLER
# -------------------------------------------------------------------- #

nothing_to_pull_handler() {
    : # Do nothing
}

repo_pulled_handler() {
    : # Do nothing
}

local_file_change_handler() {
    : # Do nothing
}

repo_pull_failed_handler() {
    echo "$1 Can not pull --> Exiting"
    exit 1
}

repo_diverged_handler() {
    echo "$1 Diverged --> Exiting"
    exit 1
}

# -------------------------------------------------------------------- #

USER_NAME=$(whoami)
SCRIPT_NAME=`basename "$0"`
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
LOG_FILE="$SCRIPT_DIR""/""$SCRIPT_NAME"".log"

# -------------------------------------------------------------------- #

ABS_DIR_TO_SYNC_IN="$SCRIPT_DIR""/""$DIR_TO_SYNC_IN"
if [ -d "$ABS_DIR_TO_SYNC_IN" ] && [ -x "$ABS_DIR_TO_SYNC_IN" ]; then
    DIR_TO_SYNC_IN="$ABS_DIR_TO_SYNC_IN"
fi

if [ ! -d "$DIR_TO_SYNC_IN" ] || [ ! -x "$DIR_TO_SYNC_IN" ]; then
    echo "Can not access directory: '$DIR_TO_SYNC_IN'"
    exit 1
fi

# -------------------------------------------------------------------- #

cd "$DIR_TO_SYNC_IN"
if [ ! -d ".git" ]; then
    echo "Not a git repository: '$DIR_TO_SYNC_IN'"
    exit 1
fi

# -------------------------------------------------------------------- #

cl-separator() {
    for i in {1..75}; do
        SEP=$SEP"-"
    done && echo $SEP && SEP=""
}

# -------------------------------------------------------------------- #

if [ "$#" -eq 0 ]; then

cl-separator
cat <<EOF
USAGE: $0 [COMMAND]

POSSIBLE COMMANDS:
    start          - Start as daemon (only one instance is possible).
    stop           - Stop the daemon.
    status         - Check if the script is already running.
    start nodaemon - Start without daemonizing.
EOF
cl-separator

exit 1
fi

# -------------------------------------------------------------------- #

START=false
STOP=false
STATUS=false
DAEMON=true

until [ -z "$1" ]; do
    if   ([ "$1" == "start"    ]); then
        START=true
    elif ([ "$1" == "stop"     ]); then
        STOP=true
    elif ([ "$1" == "status"   ]); then
        STATUS=true
    elif ([ "$1" == "nodaemon" ]); then
        DAEMON=false
    fi
    shift
done

# -------------------------------------------------------------------- #

pull() {
    cl-separator
    echo "$(date) - pulling from $UPSTREAM"
    cl-separator
    git pull origin $BRANCH_TO_SYNC
    RETURN_CODE=$?
    cl-separator

    ENVIRONMENT="[$USER_NAME | $REPO_NAME | $BRANCH_TO_SYNC | '$COMMIT_MESSAGE']"
    COMMIT_MESSAGE=$(git log -1 --pretty=%B)

    if [ $RETURN_CODE -eq 1 ]; then
        repo_pull_failed_handler "$ENVIRONMENT"
    fi

    MSG="$ENVIRONMENT Successfully pulled!"
    echo "$MSG"
}

# -------------------------------------------------------------------- #

watch-git-repo() {
    while [[ true ]]; do

        if [ -f ".git/index.lock" ]; then
            echo 'Git Repository is locked, waiting to unlock';
            sleep 2
            continue
        fi

        git fetch

        if [ -z "$BRANCH_TO_SYNC" ]; then
            BRANCH_TO_SYNC=$(\
                git branch \
                | sed -n -e 's/^\* \(.*\)/\1/p' \
                | sed -e "s/^origin\///"\
            )
            echo "$(date) - Starting to watch ($BRANCH_TO_SYNC)"
        fi

        REFS=""
        UPSTREAM="$(\
            git rev-parse --abbrev-ref \
            --symbolic-full-name @{u} 2>/dev/null\
        )"

        # upstream was not configured
        if [ -z "$UPSTREAM" ]; then
            UPSTREAM="origin/$BRANCH_TO_SYNC"
            REFS="refs/heads/"
        fi

        GIT_LOCAL=$(git rev-parse HEAD)
        GIT_REMOTE=$(git rev-parse "$REFS""$UPSTREAM")
        GIT_BASE=$(git merge-base HEAD "$REFS""$UPSTREAM")
        REPO_NAME=$(basename `git rev-parse --show-toplevel`)
        ENVIRONMENT="[$USER_NAME | $REPO_NAME | $BRANCH_TO_SYNC]"

        if [ $GIT_LOCAL = $GIT_REMOTE ]; then
            nothing_to_pull_handler "$ENVIRONMENT"
        elif [ $GIT_LOCAL = $GIT_BASE ]; then
            pull
            repo_pulled_handler "$ENVIRONMENT"
        elif [ $GIT_REMOTE = $GIT_BASE ]; then
            local_file_change_handler "$ENVIRONMENT"
        else
            repo_diverged_handler "$ENVIRONMENT"
        fi

        sleep $LOOP_INTERVAL_IN_SECONDS
    done
}

if [ "$STATUS" = true ] || ([ "$START" = false ] && [ "$STOP" = false ]); then
    cl-separator
    ps aux | grep "$SCRIPT_NAME start" | grep -v "grep $SCRIPT_NAME" | \
        grep -v " $$ "
    RETURN_CODE=$?
    if [ $RETURN_CODE -eq 0 ];then
        echo "--> Already running"
    else
        echo "Not running"
    fi
    cl-separator
    exit 0
fi

if $STOP ; then
    cl-separator
    ps aux | grep "$SCRIPT_NAME start" | grep -v "grep $SCRIPT_NAME" | \
        grep -v " $$ "
    RETURN_CODE=$?
    if [ $RETURN_CODE -eq 0 ];then
        echo "Killing $SCRIPT_NAME"
        pkill -f "$SCRIPT_NAME start"
    else
        echo -e 'Not running'
    fi
    cl-separator
    exit 0
fi

if $START ; then
    cl-separator
    ps aux | grep "$SCRIPT_NAME start" | grep -v "grep $SCRIPT_NAME" | \
        grep -v " $$ " && cl-separator && \
        echo -e '\n↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑\nAlready running!\n' && exit 1

    cd "$DIR_TO_SYNC_IN"
    git config --global credential.helper \
        "cache --timeout=$CREDENTIAL_HELPER_CACHE_IN_SECONDS"
    git fetch

    RETURN_CODE=$?
    if [ $RETURN_CODE -eq 1 ];then
        echo "Wrong password -> Exiting"
        exit 1
    fi

    if $DAEMON ; then
        echo "$(date) - Starting daemon"
        cl-separator
        ( watch-git-repo )  >> "$LOG_FILE" &
        disown
    else
        watch-git-repo
    fi

    exit 0
fi

# -------------------------------------------------------------------- #
